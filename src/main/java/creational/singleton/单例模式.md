# 单例模式

**单例模式 Singleton Pattern**：确保一个类只有一个实例，并提供一个全局访问点来访问这个唯一实例。

让类自身来负责创建和保存它的唯一实例。

# 结构

是结构最简单的设计模式，只包含一个类：单例类。

对于单例，在单例类的内部创建它的唯一实例，并通过静态方法让客户端可以使用它的唯一实例。
为防止外部对其实例化，将其构造函数设为 private。同时提供一个类型为自身的静态私有成员变量以及对应的公有静态工厂方法。

# 饿汉式/懒汉式

## 饿汉式单例

饿汉式单例 Eager Singleton 是实现起来最简单的单例类，在定义静态变量的时候实例化单例类，
在类加载时单例对象就已创建。

`private static final EagerSingleton instance = new EagerSingleton()`

## 懒汉式单例

懒汉式单例类 Lazy Singleton 的构造函数也是私有的，在第一次被引用时将自己实例化。
在类加载时不自行实例化，这种技术又称为延迟加载 Lazy Load 技术，即需要的时候再加载实例。

为了避免多个线程同时调用 getInstance 方法，可以使用 Synchronized。

直接给方法添加 synchronized 在每次调用方法时都需要进行线程锁定判断，
多线程高并发访问时会导致系统性能降低。可以无须对方法加锁，而只需对对象加锁。

通过双重检查锁定 Double-Check Locking，可以实现线程安全的单例模式。
但是可能导致系统运行效率降低，因此也不是一种完美的实现方式。

示例见 `lazy` 包下。

## 比较

- 饿汉式单例类无需考虑多个线程同时访问的问题，可以确保唯一性，从调用速度和反应时间看要更优。但从资源利用效率来讲，不如懒汉式
- 懒汉式单例类无须一直占用系统资源，但第一次使用时需要实例化，消耗更多时间，更可能出现多个线程同时首次引用，
  所以需要通过双重检查机制控制，这进一步导致系统性能受到影响

## 使用静态内部类实现单例模式

为了解决懒汉式单例类双重检查锁定的性能问题，可以通过 按需初始化持有者 Initialization on Demand Holder(IoDH) 技术实现单例模式。

IoDH 中，需要在单例类中新增一个静态内部类，在内部类中创立私有单例对象，再在单例类中将该单例对象通过 getter 返回给外部使用。

示例见 `iodh` 包下

# 优缺点/适用环境

## 优点

- 提供了对唯一实例的受控访问
- 节约系统资源，对于一些需要频繁创建和销毁的对象，可以提高系统性能
- 可以基于单例模式扩展，获得指定个数的实例对象（多例类）

## 缺点

- 没有抽象层，扩展困难
- 职责过重，创建和功能耦合
- 很多面向对象语言提供了自动垃圾回收技术，如果共享对象长时间不被利用，可能被回收，导致共享的单例对象状态的丢失

## 适用环境

- 系统只需要一个实例对象，或只允许创建一个对象
- 客户调用类的单个实例只允许访问一个公共访问点，不能通过其他途径访问该实例

# 本例

定义一个负载均衡器，负责将并发流量分发到服务器集群中的多台设备上。需要确保负载均衡器的唯一性。


