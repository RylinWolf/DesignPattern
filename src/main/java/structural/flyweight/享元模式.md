# 享元模式

**享元模式 Flyweight Pattern**：运用共享技术有效地支持大量细粒度对象的复用。

享元模式通过共享技术实现相同或相似对象的重用。相同的对象都指向一个实例，享元模式中存储这些实例的地方称为**享元池 Flyweight
Pool**。

享元模式能做到共享的关键是区分了**内部状态 Intrinsic State**和**外部状态 Extrinsic State**。通常将内部状态作为具体享元类的成员变量，
外部状态通过注入的方式添加到具体享元类中。

享元模式要求能够被共享的对象必须是细粒度对象，它又称为轻量级模式。享元模式是一种对象结构型模式。

享元模式引入了享元工厂类，用于提供一个存储享元对象的享元池。用户需要对象时首先从享元池中获取，如果享元池中不存在，则创建一个新的享元对象返回给用户，
并在享元池中保存该新增对象。

# 结构

较为复杂，通常结合工厂模式一起使用。

- **Flyweight 抽象享元类**：通常是一个接口或抽象类。拥有方法用以向外界提供享元对象的内部数据以及设置外部数据。
- **ConcreteFlyweight 具体享元类**：实现抽象享元类。可以结合单例模式来设计，为每个具体享元类提供唯一的享元对象。
- **UnsharedConcreteFlyweight 非共享具体享元类**：不能被共享的子类。可以直接通过实例化创建。
- **FlyweightFactory 享元工厂类**：用于创建并管理享元对象。将各种类型的具体享元对象存储在一个享元池中，享元池一般设计为一个存储键值对的集合。

# 单纯享元模式与复合享元模式

## 单纯享元模式

所有的具体享元类都是可以共享的，不存在非共享具体享元类。

## 复合享元模式

将一些单纯享元对象通过组合模式加以组合，形成复合享元对象。这样的复合享元对象本身不能共享，但可以分解成单纯享元对象。

### 结构

- FlyweightFactory 享元工厂
- Flyweight 抽象享元类
- ConcreteFlyweight 具体享元类
- CompositeConcreteFlyweight 复合享元类
    - 作为组合模式的容器构件
    - 维护一个抽象享元类对象集合的引用
    - 提供添加、移除享元对象的方法

# 享元模式与 String 类

JDK 中的 String 类使用了享元模式。在创建内容相同的字符串对象时，不会重新分配内存空间，会引用相同的对象。
若对创建的字符串对象进行修改，则将会创建一个新的对象，并在新的对象上进行修改。
这种在修改享元对象时先将原有对象复制一份，然后在新对象上实施修改操作的机制称为“Copy On Write 写入时复制”（COW）。

# 本例

开发一个围棋软件。围棋包含大量的黑子和白子，形状、大小一模一样，只是出现的位置不同。如果将每个棋子作为独立的对象，将导致内存占用较大。
为了解决该问题，使用享元模式来设计棋子对象。

## 分析

- 创建 BaseIgoChessman 围棋棋子类充当抽象享元类
- 创建 BlackIgoChessman、WhiteIgoChessman 具体享元类
- 创建 IgoChessmanFactory 围棋棋子工厂类，充当享元工厂类，使用单例模式设计

由于棋子需要能够多次重复显示，位于不同位置，因此需要为其添加外部状态。 在本例中，需要将棋子的位置定义为外部状态，在需要时进行设置。

- 增加坐标类 Coordinates 用于存储每一个棋子的位置
- 修改抽象享元类的展示方法，将位置信息作为参数传入
