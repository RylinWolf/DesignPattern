# 适配器模式

**适配器模式 Adapter**：将一个类的接口转换成客户希望的另一个接口，让那些不兼容的接口可以一起工作。

适配器模式可以将一个类的接口和另一个类的接口匹配起来，而无需修改原来的适配者接口和抽象目标类接口。

别名为**包装器模式 Wrapper**。既可以作为类结构型模式，也可作为对象结构型模式。定义中所提及的接口指广义的接口，
可以表示一个方法或者方法的集合。

适配器模式更多强调的是**代码的组织**，而**不是功能的实现**。

# 结构

- Target 目标抽象类：定义客户所需的接口，可以是抽象类或接口或具体类。在类适配器中，只能是接口
- Adapter 适配器类：可以调用另一个接口，作为转换器，对 Adaptee 和 Target 进行适配。
  是适配器模式的核心，在类适配器中，通过实现 Target 接口并继承 Adaptee 来使两者产生联系；
  在对象适配器中，通过继承 Target 并关联一个 Adaptee 对象使两者产生联系
- Adaptee 适配者类：被适配的角色，定义了一个已经存在的接口，需要进行适配。一般是一个具体类，包含客户希望使用的业务方法，某些情况下甚至没有源代码。

# 变体

## 缺省适配器模式 Default Adapter Pattern

**缺省适配器模式**：当不需要实现一个接口提供的所有方法时，可以先设计一个抽象类实现该接口，
并为接口重的每个方法提供一个默认实现（空方法），那么该抽象类的子类可以选择性覆盖父类的某些方法来实现需求。

适用于不想使用一个接口中的所有方法的情况，又称为单接口适配器模式。

示例位于`defaultadapter`包下。

### 结构

- ServiceInterface 适配者接口：是一个接口，声明了大量的方法
- AbstractServiceClass 缺省适配器类：是缺省适配器模式的核心，使用空方法的形式实现了适配者接口中声明的方法。通常定义为抽象类，因为实例化无意义。
- ConcreteServiceClass 具体业务类：缺省适配器类的子类，在没有引入适配器之前需要实现适配者接口，因此需要实现在适配者接口中定义的所有方法。
  而对于一些无须使用的方法不得不提供空实现，有了缺省适配器后可以直接继承适配器类，选择性覆盖方法。

## 双向适配器

如果适配器中同时包含对目标类和适配者类的引用，适配者可以通过它调用目标类中的方法，目标类也可通过它调用适配者类中的方法，则该适配器是一个双向适配器。

示例代码如下：

```java
public interface Target {
    void request();
}

public interface Adaptee {
    void specificRequest();
}

public class Adapter implements Target, Adaptee {
    /**
     * 同时维持对抽象目标类和适配者的引用
     */
    private Target target;
    private Adaptee adaptee;

    public Adapter(Target target) {
        this.target = target;
    }

    public Adapter(Adaptee adaptee) {
        this.adaptee = adaptee;
    }

    @Override
    public void request() {
        this.adaptee.specificRequest();
    }

    @Override
    public void specificRequest() {
        this.target.request();
    }
}
```

# 优缺点/适用环境

## 优点

- 将目标类与适配者类解耦，通过引入适配器类来重用现有的适配者类，而无需修改原有结构
- 增加了类的透明性和复用性
- 灵活性和扩展性好，通过配置文件可以方便更换适配器，也方便增加新的适配器，符合开闭原则
- 类适配器：由于适配器类是适配器者类的子类，可以置换一些适配者的方法，灵活性更强
- 对象适配器
    - 可以把多个不同的适配者适配到同一个目标
    - 由于适配器和适配者是关联关系，根据里氏代换原则，可以适配一个适配者的子类。

## 缺点

### 类适配器

- 对于不支持多重类继承的语言，一次最多只能适配一个适配者类
- 适配者类不能为最终类，例如 Java 中不能为 final 类
- 在Java、C#等语言中，目标抽象类只能为接口，不能为类，使用有局限性（因为不支持多重继承）

### 对象适配器

置换适配者类的某些方法比较麻烦，需要先做适配者的子类，将适配者类的方法置换掉，再把适配者的子类当成真正的适配者进行适配。

## 适用环境

- 系统需要使用一些现成的类，而接口不符合系统的需要，甚至没有这些类的源代码
- 想创建一个可以重复使用的类，用于和一些彼此之间没有太大关联的类一起工作。

# 本例

开发一款玩具汽车，移动过程中伴随灯光闪烁和声音提示。以往的产品中已经实现了控制程序，为了重用代码并使汽车控制软件具有更好灵活性和扩展性，
使用适配器模式设计控制软件。

## 分析

- 选择使用对象适配器模式进行设计
- 创建适配者和目标抽象类（分别位于 `adaptee` 和 `target` 包下），创建对应业务方法
- 创建适配器类，继承目标抽象类，重写抽象方法
- 在适配器类中创建对适配类的关联，通过对象引用的方式完成业务方法
- 在 XML 中指定具体适配器类，客户端读取 XML 配置，创建目标抽象类对象，调用业务方法


