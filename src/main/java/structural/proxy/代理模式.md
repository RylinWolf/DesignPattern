# 代理模式

**代理模式 Proxy Pattern**: 给某一个对象提供一个代理或占位符，并由代理对象来控制对原对象的访问。

由于某些原因，客户端不想或不能直接访问一个对象，此时可以通过一个称为“代理”的第三者来实现间接访问。
该方案对应的设计模式被称为代理模式。

代理模式是一种应用很广泛的结构型设计模式，变化形式非常多，有远程代理、保护代理、虚拟代理、缓冲代理、智能引用代理等。

代理模式是一种对象结构型模式，引入了一个新的代理对象，在客户端对象和目标对象之间起到中介的作用。

# 结构

- Subject 抽象主题角色：声明了真实主题和代理主题的共同接口
- Proxy 代理主题角色：包含了对真实主题的引用，从而可以在任何时候操作真实主题。
  提供了一个与真实主题角色相同的接口，可以控制对真实主题的使用，负责在需要的时候创建和删除真实主题对象。
- RealSubject 真实主题角色：定义了代理角色所代表的真实对象。

# 实现

- 抽象主题类声明真实主题类和代理类的公共方法，可以是接口、抽象类或具体类
- 真实主题类、代理类是抽象主题类的子类
- 代理类维持一个对真实主题类的引用，调用相关方法，并对功能进行扩充或约束

## 代理模式种类

实际开发中，代理类的设计会很复杂。常用的代理模式如下：

- 远程代理 Remote Proxy：为一个位于不同地址空间的对象提供一个本地的代理对象，又称**大使 Ambassador**
- 虚拟代理 Virtual Proxy：先创建一个消耗较小的对象来表示一个资源消耗较大的对象，真实对象在需要时才会被创建
- 保护代理 Protect Proxy：控制对一个对象的访问，比如可以给不同的用户提供不同级别的使用权限
- 缓冲代理 Cache Proxy：为某一个目标操作的结果提供临时的存储空间，以便多个客户端可以共享
- 智能引用代理 Smart Reference Proxy：当一个对象被引用时提供一些额外的操作，例如将对象被调用的次数记录下来

# 本例

开发一个商务信息查询系统，实现以下基本需求：1.在进行商务信息查询之前对用户进行身份验证；2. 在查询时记录查询日志，以便收取查询费用。
现需要通过松耦合的方式向原有系统增加身份验证和日志记录功能，使用代理模式设计并实现。

## 分析

在客户端和信息查询对象之间增加一个代理对象，实现身份验证和日志记录等功能。

- 新增业务类 AccessValidator 用于验证身份
- 新增业务类 Logger 用于记录日志
- Searcher 充当抽象主题角色，RealSearcher 充当真实主题角色，ProxySearcher 充当代理主题角色

# 其他代理模式

## 远程代理

远程代理 Remote Proxy 使得客户端可以访问远程主机上的对象。客户端完全可以认为被代理的远程业务对象是在本地，
而远程代理对象承担了大部分的网络通信工作，并负责对远程业务方法的调用。

Java 中可以通过 RMI（Remote Method Invocation，远程方法调用）机制来实现远程代理。它能实现一个 Java 虚拟机中的对象调用另一个
Java 虚拟机中对象的方法。RMI 中，客户端对象可以通过一个桩（Stub）对象与远程主机上的业务对象进行通信。桩对象就是远程业务对象在本地主机的代理。

RMI 实现的过程中，远程主机端有一个 Skeleton（骨架）对象负责与 Stub 通信。基本实现步骤如下：

1. 客户端发起请求，请求转交至 RMI 客户端的 Stub 类
2. Stub 将请求的接口、方法、参数等信息序列化
3. 序列化的流使用 Socket 传输至服务器端
4. 服务器接收到流后将其转发至相应的 Skeleton 类
5. Skeleton 将请求反序列化后调用实际的业务处理类
6. 业务处理类处理完毕后将结果返回给 Skeleton
7. Skeleton 将结果序列化，再通过 Socket 将流传送给客户端的 Stub
8. Stub 反序列化，将反序列化后的 Java Object 返回给客户端调用者

## 虚拟代理

为某对象提供一个虚拟代理，在真实对象创建成功之前，该虚拟代理扮演真实对象的替身。当真实对象创建之后，虚拟代理将用户请求转发给真实对象。
通常以下情况可以考虑使用虚拟代理：

- 对象本身的复杂性或网络等原因导致一个对象需要较长的加载时间，此时可以用一个加载时间相对较短的代理对象来代替。
  通常实现时可以结合多线程，一个线程用于显示代理对象，其他用于加载真实对象。可以应用于程序启动时，用代理对象代替真实对象初始化，缩短系统启动时间。
- 一个对象的加载十分消耗系统资源时也很适合使用虚拟代理。把复杂对象的创建推迟到使用时，可以节省内存空间，是一种用时间换空间的做法。

## Java 动态代理

传统的代理模式，通过 Proxy 调用 RealSubject 的方法，同时在代理类中封装其他方法，
要求代理类和真实主题类都是事先存在的，且代理类接口和所代理方法明确指定。 每个代理类在编译之后都会生成一个 class
文件，代理类实现的接口和代理的方法都被固定，这种代理被称为**静态代理 Static Proxy**。

在静态代理下，如果需要为不同的真实主题类提供代理或代理一个真实主题类中的不同方法，都需要增加新的代理类，
这会导致系统中的类数量急剧增加。

**动态代理 Dynamic Proxy** 可以让系统在运行时根据实际需要动态创建代理类，让同一个代理类能代理多个不同的真实主题类、不同方法。
动态代理是一种较高级的代理模式，在事务管理、AOP 等领域都有重要作用。

JDK1.3 开始，Java 提供了对动态代理的支持，实现时需要用到 `java.lang.reflect` 包中的一些类。

### Proxy

提供了创建动态代理类和实例对象的方法。

- getProxyClass(ClassLoader, Class<?>...)： 返回一个 Class 类型的代理类，参数中需要提供类加载器，指定代理的接口数组(
  与真实主题类的接口列表一致)
- newProxyInstance(ClassLoader, Class<?> [], InvocationHandler): 返回一个动态创建的代理类实例，第三个参数表示所指派的调用处理程序类。

### InvocationHandler

是代理处理程序类的实现接口，作为代理实例的调用处理者的公共父类。每个代理类的实例都可提供一个相关的具体调用处理者（InvocationHandler
的子类）。

- invoke(Object, Method, Object[]): 处理对代理类实例的方法调用，并返回相应的结果。参数分别为代理类实例、需要代理的方法、代理方法的参数数组。

动态代理类需要在运行时指定所代理真实主题类的接口，客户端调用动态代理对象的方法时，调用请求会自动转发给 invoke 方法。
invoke 方法实现对请求的统一处理。

### 实例

为公司 OA（Official Automation 办公自动化）系统的 DAO 层增加方法调用日志，记录方法被调用的时间和调用结果。
使用动态代理设计。

#### 分析

- 创建抽象主题角色 AbstractUserDao、AbstractDocumentDao，分别为抽象用户 DAO、抽象文档 DAO
- 创建具体主题角色 UserDao、DocumentDao
- 创建自定义请求处理程序类 DaoLogHandler 
