# 装饰模式

**装饰模式 Decorator Pattern**：动态地给一个对象增加一些额外的职责。就扩展功能而言，装饰模式提供了一种比使用子类更加灵活的替代方案。

装饰模式可以在不改变一个对象本身功能的基础上给对象增加额外的新行为。是一种对象结构型模式。

# 结构

- **Component 抽象构件**：是具体构件和抽象装饰类的共同父类，它的引入可以使客户端以一致的方式处理未被装饰的对象以及装饰之后的对象，实现客户端的透明操作
- **ConcreteComponent 具体构件**：实现抽象构件中声明的方法，装饰类可以给它增加额外的职责
- **Decorator 抽象装饰类**：也是抽象构件类的子类，用于给具体构件增加职责。
  维护一个抽象构件对象的引用，通过该引用可以调用装饰之前构件对象的方法，通过其子类扩展该方法，以达到装饰目的
- **ConcreteDecorator 具体装饰类**：抽象装饰类的子类，可以调用抽象装饰类中定义的方法，并增加新的方法以扩充对象的行为

# 透明装饰模式/半透明装饰模式

标准的装饰模式中，新增行为需要在原有业务方法中调用，无论是具体构件对象还是装饰过的对象，对于客户端而言都是透明的，这种装饰模式为
**透明 Transparent 装饰模式**。

有些情况下，有些新增行为可能需要单独被调用，此时客户端不能一致地处理装饰前后的对象，这种装饰模式为**半透明 Semi-transparent
装饰模式**。

## 透明装饰模式

要求客户端完全针对抽象编程。不应该将对象声明为具体构件或装饰类型，而应声明为抽象构件类型。

在实现透明装饰模式时，要求具体装饰类的操作方法覆盖抽象装饰类的操作方法，还需要调用新增的附加行为方法。

## 半透明装饰模式

透明装饰模式设计难度较大，有时需要单独调用新增的业务方法。不得不用具体装饰类来定义装饰之后的对象，具体构件类型仍然可以使用抽象构件类型来定义。

对于客户端而言，具体构件类型是透明的，但具体装饰类型是需要指定、不透明的。

半透明装饰模式可以给系统带来更多灵活性，设计相对简单，使用方便，但缺点是不能实现对一个对象的多次装饰。
而且客户端需要有区别地对待装饰前后的对象。

在实现半透明装饰模式时，只需要在具体装饰类中增加一个独立的 addBehavior 方法来封装相对应的业务处理，
由于客户端使用具体装饰类型来定义装饰后的对象，因此可以单独调用该方法。

# 优缺点/适用环境

## 优点

- 对于扩展一个对象的功能，装饰模式比继承更灵活
- 可以通过动态的方式扩展一个对象的功能
- 可以对一个对象多次装饰，得到功能更强大的对象
- 具体构件类和具体装饰类可独立变化，用户可根据需要增加新的具体构件类和具体装饰类，符合开闭原则

## 缺点

- 使用装饰模式进行系统设计时将产生很多小对象，这些对象的区别在于相互连接的方式有所不同而不是类或属性值不同，在一定程度上影响系统性能
- 意味着比继承更容易出错，排错也更加困难。对于多次装饰的对象，寻找错误较为繁琐

## 适用环境

- 在不影响其他对象的情况下以动态、透明的方式给单个对象添加职责
- 在不能采用继承的方式扩展系统或继承不利于系统维护时可以使用装饰模式
    - 不能采用集成的情况主要有：
        - 系统中存在大量的独立扩展，为支持每一种扩展或扩展之间的组合将产生大量子类
        - 类已定义为不能被继承

# 本例

开发一套图形界面构件库，提供大量基本构件。由于用户要求定制显示效果，所以经常需要对该构件库进行扩展以增强其功能。
使用装饰模式来设计该图形界面构件库。

## 分析

- AbstractComponent 充当抽象构件类，其子类 Window、TextBox、ListBox 充当具体构件类；另一个子类 ComponentDecorator
  充当抽象装饰类，其子类
  ScrollBarDecorator 和 BlackBorderDecorator 充当具体装饰类
- 抽象装饰类需要维护一个抽象构件类引用，可通过构造方法传递
- 创建所需类，在客户端中创建具体构件类实例
- 使用构件类实例作为构造函数参数，创建具体装饰类实例
- 调用装饰类业务方法，查看装饰效果
