# 桥接模式

**桥接模式 Bridge Pattern**：将抽象部分与它的实现部分解耦，使得两者都能够独立变化

是一种对象结构型模式，又被称为 **柄体模式(Handle and Body)** 或接口模式。
桥接模式用一种巧妙的方式处理多层继承中存在的问题，用抽象关联取代传统的多层继承。将类之间的静态继承关系转换为动态的对象组合关系，
使得系统更加灵活，有效控制了系统中类的个数。

是一个非常实用的设计模式，体现了很多面向对象设计原则思想，包括单一职责原则、开闭原则、合成复用原则、里氏代换原则、依赖倒转原则等。
使用时应该首先识别出一个类具有的两个独立变化的维度，设计成两个独立的继承等级结构，为两个维度都提供抽象层。
通常情况下，将具有两个独立变化维度的类的一些普通业务方法和与之关联最密切的维度设计为“抽象类”层次结构，另一个维度设计成“实现类”层次结构。

例如对于毛笔而言，型号是固有的维度，因此可以设计一个抽象的毛笔类，其中声明并实现部分基本业务方法，将各种型号的毛笔作为其子类；
颜色是毛笔的另一个维度，因此可以提供一个抽象的颜色接口，而将具体的颜色作为该接口的子类。在此，型号可认为是毛笔的抽象部分，而颜色是毛笔的实现部分。

以上毛笔示例位于`brush`包下。

# 结构

- Abstraction 抽象类：通常是抽象类，其中定义并维护一个Implementor 实现类接口。可以包含抽象业务方法或具体业务方法。
- RefinedAbstraction 扩充抽象类：扩充由 Abstraction 定义的接口。通常为具体类。实现抽象业务方法，可以调用在 Implementor
  中定义的业务方法。
- Implementor 实现类接口：不一定要与抽象类接口完全一致，可以完全不同。一般只声明基本操作，具体实现交给子类。
- ConcreteImplementor 具体实现类：在不同具体实现类中提供基本操作的不同实现。

# 与适配器模式的联用

适配器模式通常与桥接模式联合使用。适配器模式可以解决两个已有接口不兼容的问题，通常用于现有系统和第三方产品功能集成。

桥接模式用于系统的初步设计，对于存在两个独立变化维度的类可以分为抽象化和实现化两个角色，使他们分别变化。

初步设计完成之后，发现系统与已有类无法协同工作时可以采用适配器模式。但有时候，设计初期也需要考虑适配器模式，特别是大量涉及第三方应用接口的情况。

# 优缺点/适用环境

## 优点

- 分离抽象接口及其实现部分，使用对象间的关联关系，使得抽象和实现可以沿着各自的维度来变化。
  也就是说，抽象和实现不在同一个继承层次结构中，而是“子类化”它们，使它们各自具有自己的子类，以便任意组合子类，从而获得多维度组合对象。
- 很多情况下，可以取代多层继承方案。
- 提高了系统的可扩展性，在两个维度中扩展不需要修改原有代码，符合开闭原则。

## 缺点

- 增加系统理解与设计难度，关联关系建立在抽象层，需要一开始就设计抽象层
- 要求正确地识别出系统中两个独立变化的维度，使用范围有局限性

## 适用环境

- 系统需要在抽象化和具体化之间增加更多的灵活性，避免在两个层次之间建立静态的继承关系
- 系统需要对抽象化角色和实现化角色动态耦合
- 一个类存在两个或多个独立变化的维度，且这些维度都需要独立扩展
- 不希望使用继承或因为多层继承导致类的个数急剧增加的系统

# 本例

开发一个跨平台图像浏览系统，要求显示多种格式文件，且能在 Windows、Linux、Unix 等多系统上运行。
系统首先将各种格式文件解析为像素矩阵 Matrix，然后将像素矩阵显示在屏幕上，在不同操作系统中可调用不同绘制函数来绘制矩阵。
系统需具有较好的扩展性，以支持新的文件格式和操作系统。
试使用桥接模式来设计该系统。

示例位于 `img` 包下

## 分析

- Image 充当抽象类， 子类 JPGImage、PNGImage、BMPImage、GIFImage 作为扩充抽象类
- ImageImp 充当实现类接口，子类 WindowsImp、LinuxImp、UnixImp 充当具体实现类
- 创建 Matrix 辅助类
- 在抽象类中，维护一个对实现类接口的引用，并声明业务方法
- 在具体实现类中，实现业务方法
- 在扩充抽象类中，调用实现类的方法，实现业务方法
